---
output: 
  word_document:
    reference_docx: cmar_report_template_3.docx
    toc: true
    toc_depth: 3
params: 
  county: county 
  doc.hist: doc.hist
editor_options: 
  chunk_output_type: console
bibliography: water_qaulity_references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, dpi = 600)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}

library(canadianmaps)
library(docalcs)
library(dplyr)
library(ggplot2)
library(ggthemes)
library(ggsflabel)
library(ggspatial)
library(glue)
library(here)
library(knitr)
library(lubridate)
library(purrr)
library(qaqcmar)
library(readr)
library(sf)
library(sensorstrings)
library(stringr)
library(tidyr)
library(viridis)

source(here("functions/subchunkify.R"))
source(here("functions/import_map_params.R"))

county <- params$county

filter_table <- read_csv(here("filter_not_evaluated_flags.csv"), 
  col_types = "ccccnll",
  show_col_types = FALSE) %>% 
  separate(
    deployment_range, 
    into = c("start_date", "end_date"), sep = " to ",
    remove = FALSE) %>% 
  mutate(
    qc_flag_value = ordered(qc_flag_value, levels = 1:4),
    start_date = as_datetime(start_date),
    end_date = as_datetime(end_date)
  ) %>% 
  filter(county == county) 
```

 
```{r, import-strings-data}

vars <- c(    
  "dissolved_oxygen_percent_saturation",
  "dissolved_oxygen_uncorrected_mg_per_l",
  "salinity_psu",
  "sensor_depth_measured_m",
  "temperature_degree_c"
)

# read all rds files for county and rbind together
dat_raw <- suppressMessages(ss_import_data(county = county))

if(!("lease" %in% colnames(dat_raw))) {
  dat_raw <- mutate(dat_raw, lease = NA_character_)
}

dat <- dat_raw %>% 
  qc_pivot_longer() %>% 
  qc_filter_summary_flags() %>% 
  qc_filter_out_not_evaluated(filter_table) %>% 
  qc_pivot_wider() %>% 
  select(
    waterbody, station, lease, latitude, longitude,
    deployment_range, string_configuration,
    sensor_type, sensor_serial_number, sensor_depth_at_low_tide_m, timestamp_utc,
    any_of(vars)
  )

# unique waterbodies
waterbodies <- sort(unique(dat$waterbody))

fig_caption <- " water quality data."
table_caption <- "Deployment details for"

i = 1 # counter for table
k = 1 # counter for figure number
text_size <- 3
crs <- 4326

# stations that have DO below the default range of plot_variables_at_depth
custom_DO_lims <- c(
  "0814x East",
  "0814x West",
  "5008",
  "Aberdeen", 
  "Deep Basin",
  "Hourglass Lake",
  "Monks Head",
  "Piper Lake", 
  "Sissiboo",
  "Tickle Island"
) 

# dissolved oxygen units considerations
if("dissolved_oxygen_uncorrected_mg_per_l" %in% colnames(dat)) {

  dat <- dat %>%
    do_salinity_correction(sal = 30.6) %>% 
    mutate(
      dissolved_oxygen_mg_per_l = dissolved_oxygen_uncorrected_mg_per_l * F_s
    ) %>% 
    select(-c(dissolved_oxygen_uncorrected_mg_per_l, salinity_psu, F_s))

  DO_mgL <- TRUE

} else DO_mgL <- FALSE

```


\newpage
# Introduction

The Centre for Marine Applied Research (CMAR) measures [essential ocean variables](https://www.goosocean.org/index.php?option=com_content&view=article&layout=edit&id=283&Itemid=441) throughout Nova Scotia’s coastal waters as part of the Coastal Monitoring Program. This program was initiated by the Nova Scotia Department of Fisheries and Aquaculture in 2012 and CMAR became involved in 2017. For more information on CMAR and the Coastal Monitoring Program, visit the [CMAR website](https://cmar.ca/). 

This document presents deployment details and summary figures of Water Quality data collected for **`r county` County** (Figure `r k` and Figure `r k+1`). The data are available for download from the Nova Scotia [Open Data Portal](https://data.novascotia.ca/browse?tags=coastal+monitoring+program) and from the ERDAPP server through the [Canadian Integrated Ocean Observing platform](https://catalogue.cioosatlantic.ca/dataset?q=cmar). 

This document should be considered as a guide only, as data collection and retrieval are ongoing. The information may be revised pending ongoing data collection and analyses. 

```{r, NS-map, message=FALSE, warning=FALSE, error=FALSE, fig.width=8}

# NS county boundaries
ns <- read_sf(here("data/merged_counties2/Merged_Counties2.shp")) %>% 
  na.omit() %>% 
   mutate(
    col_county = if_else(County == county, 1, 0),
    col_county = ordered(factor(col_county), levels = c(1, 0))
  ) %>% 
  st_transform(crs = crs) 

bbox <- st_bbox(ns)

nb_pei <- filter(PROV, PT == "NB"|PT=="PE") %>%
  st_transform(crs = crs) %>% 
  mutate(
    col_county = 0, 
    col_county = ordered(factor(col_county), levels = c(1, 0))
  )

can <- bind_rows(
  ns %>% st_simplify(dTolerance = 1000), 
  nb_pei
) %>% 
  st_crop(bbox) 

ggplot() +
  geom_sf(data = can, aes(fill = col_county)) +
  scale_fill_manual(values = c("#1B9E77", "grey90")) +
  theme_map() +
  coord_sf(expand = TRUE) +
  theme(
    panel.border = element_rect(colour = "black", fill = NA, linewidth = 1),
    text = element_text(size = 12),
    axis.title = element_blank(),
    legend.position = "none"
  )

```

Figure `r k`: `r county` County (green).

```{r,  message=FALSE, error=FALSE}
k = k + 1
```


```{r, county-map, message=FALSE, error=FALSE, warning=FALSE, fig.width=8}

if(county == "Guysborough") text_size <- 2.5

map_params <- import_map_params(county)

# extract unique station locations and convert to sf object
stations_sf <- dat %>%
  sensorstrings::ss_write_report_table(keep_waterbody = TRUE) %>%
  select(Waterbody, Station, Latitude, Longitude) %>%
  distinct(Station, .keep_all = TRUE) %>%
  st_as_sf(
    coords = c("Longitude", "Latitude"), remove = FALSE,
    crs = crs, agr = "constant"
  )

county_sf <- ns %>% 
  st_crop(map_params$dummy_points) 

ggplot() +
  geom_sf(data = county_sf) +
  geom_sf(data = stations_sf) +
  geom_sf_label_repel(
    data = stations_sf, aes(label = Station),
    label.size = NA,
    fill = NA, size = text_size,
    max.overlaps = 40
  ) +
  coord_sf(expand = FALSE) +
  annotation_scale(location = "br") +
  annotation_north_arrow(
    location = "tl", which_north = "true",
    height = unit(1, "cm"),
    width = unit(1, "cm")
  ) +
  theme_map() +
  theme(
    panel.border = element_rect(colour = "black", fill = NA, size = 1),
    text = element_text(size = 12),
    axis.title = element_blank()
  )

```	
<br>


Figure `r k`: Sampling stations in `r county` County.

```{r}
k = k+1
```

\newpage
## Data Collection 

CMAR collects temperature, dissolved oxygen, and salinity data using moorings referred to as "sensor strings". A typical sensor string configuration consists of a rope attached to the seafloor by an anchor and suspended by a sub-surface buoy, with sensors attached at various depths below the surface (Figure `r  k`). Most strings deployed since 2018 are attached to the anchor by an acoustic receiver with a release mechanism. Alternatively, strings may be attached to surface moorings, including floating docks, buoys, and equipment (Table `r i`). 

```{r, echo=FALSE, fig.width=8}
knitr::include_graphics("sensor_string.png")
```

Figure `r k`: Example sensor string configuration (not to scale).

Sensor strings are typically deployed for several months, and data are measured every 1 minute to 1 hour. Sensors are retrieved for data offload by triggering the acoustic release when applicable, by directly removing from surface moorings, or occasionally by divers or grappling methods (Table `r i`). Sensor strings may be re-deployed at the same location or moved to another area of interest depending on program objectives.

\newpage

Table `r i`: Description of sensor string configurations.

| **Configuration** | **Description** |
|---|---|
|     Sub-surface buoy    |     Attached to sub-surface buoy. Typically has an acoustic release, but sometimes retrieved by diver or drag line. Does not float with the tide.    |
|     Surface buoy    |     Attached to a surface buoy. Floats with the tide.    |
|     Attached to gear    |     Typically attached to aquaculture gear (especially if associated with lease), but may be attached to another structure. Floats with the tide.  |
|     Attached to fixed structure    |     Typically attached to a wharf, but may be attached to a bridge or pole. Does not float with the tide.  |
|     Floating dock    |     Attached to a floating dock. Floats with the tide.    |
|     Unknown    |     Configuration not indicated in deployment log.    |


Stakeholder needs characteristics of the station location dictate the string design. Sensor strings are generally deployed 200 m to 1000 m from shore, in depths up to 75 m. Historically, strings were deployed with only temperature sensors, but in more recent years at least one dissolved oxygen sensor is included (typically at 5 m below the surface). At the request of industry, salinity sensors are also included at stations near proposed and existing shellfish aquaculture leases. Some of the sensors used to measure these variables also measure sensor depth. CMAR has processed and published this opportunistic data with the Water Quality datasets, and included it in the figures below.

## Quality Control

Automated Quality Control tests were applied to the data to identify outlying and unexpected observations. Following QARTOD guidance, each data point was assigned a flag of “Pass”, “Fail”, “Suspect/Of Interest”, or “Not Evaluated” [@RN25922]. Observations flagged as “Pass” passed all tests and were included in the figures below. Observations that failed any test were considered poor quality data and excluded from the figures.

**Observations flagged as “Suspect/Of Interest” were treated differently depending on the variable. Temperature and measured sensor depth observations are considered "Of Interest", and included in the figures below. In contrast, dissolved oxygen observations flagged as “Suspect/Of Interest” are typically indicative of biofouling. These observations are considered "Suspect", and excluded from the figures. Salinity observations flagged as "Suspect/Of Interest" were also considered "Suspect" and excluded.**

Some tests cannot be applied to certain observations, which were flagged as “Not Evaluated”. These observations were included in the figures. 

Quality Control tests were applied using the CMAR R package [qaqcmar](https://github.com/dempsey-CMAR/qaqcmar).
For more technical details about the Quality Control tests, visit the CMAR [Data Governance website](https://dempsey-cmar.github.io/cmp-data-governance/pages/cmp_about.html).


`r if(DO_mgL){"## Dissolved Oxygen \nDissolved oxygen was measured in units of percent saturation or mg/L, depending on the deployment. Measurements in mg/L were corrected for salinity using the Garcia-Gordon (1992) salinity correction factor [@RN24366] with a salinity value of 30.6 practical salinity units (based on available data for the region). This correction factor is not required for values recorded in percent saturation. The correction facor calculations are available in the CMAR R package [docalcs](https://github.com/dempsey-CMAR/docalcs)."}`

\newpage
# `r county` County Water Quality Data

Water Quality data is presented by waterbody. For each waterbody, there is a table of deployment details followed by figures showing the data at each station. **A red line is included in temperature figures to indicate the -0.7 °C superchill threshold for salmonids (for figures where the temperature falls below this threshold). Note the different axis scales for each figure.**


```{r, report-body, fig.width = 8.5, results = 'hide',  results ='asis', message=FALSE}

for(i in seq_along(waterbodies)){

  waterbody_i <- waterbodies[i]
  dat_i <- dat %>% filter(waterbody == waterbody_i)

  stations <- sort(unique(dat_i$station))
  
  cat('\n##', waterbody_i, '\n')

  cat('\n')

  # waterbody table
  table_i <- ss_write_report_table(dat_i, keep_waterbody = FALSE)

  print(
    kable(table_i, align = "c",
          caption = glue("Table {i+1}: {table_caption} {waterbody_i}.")
    )
  )
  
  cat('\n')
  
  # plot for each station
  for(j in seq_along(stations)){

    k = k + 1
    station_j <- stations[j] # station of interest

    # subset data to station of interest
    dat_j <- dat_i %>% 
      filter(station == station_j) %>%
      ss_convert_depth_to_ordered_factor()

    # # y-limts for DO
    # if(station_j %in% custom_DO_lims){
    #   standard_lims = FALSE
    # } else standard_lims = TRUE
    
    # height of figure j
    n_vars <- dat_j %>% ss_pivot_longer() %>% distinct(variable) %>% nrow()
    if(n_vars == 1) h = 2.5
    if(n_vars == 2) h = 5
    if(n_vars == 3) h = 7.5
    if(n_vars == 4) h = 10
    
    p <- ss_ggplot_variables(dat_j)
    
    cat('\n###', station_j, '\n')
     
    subchunkify(p, fig_height = h, fig_width = 8.5)
    
    cat(paste("Figure ", k, ": ", station_j, fig_caption,  sep = ""), '\n')
    
    cat('\n')
  }
}

```

\newpage
# Document History

```{r}
i = i +1

params$doc.hist %>% 
  select(-County) %>% 
  kable(
    align = "ccl", caption = glue("Table {i}: Document history.")
  )

```
<br>

# References

